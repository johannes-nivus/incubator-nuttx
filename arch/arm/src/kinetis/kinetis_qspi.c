/****************************************************************************************************
 * arch/arm/src/kinetis/kinetis_qspi.c
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.  The
 * ASF licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the
 * License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 ****************************************************************************************************/

/****************************************************************************
 * Included Files
 ****************************************************************************/

#include <nuttx/config.h>

#include <sys/types.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <assert.h>
#include <debug.h>

#include <arch/board/board.h>

#include <nuttx/arch.h>
#include <nuttx/wdog.h>
#include <nuttx/clock.h>
#include <nuttx/kmalloc.h>
#include <nuttx/semaphore.h>

#include "arm_internal.h"
#include "arm_arch.h"
#include "barriers.h"

#include "kinetis.h"
#include "kinetis_qspi.h"

#include "hardware/kinetis_memorymap.h"
#include "hardware/kinetis_pinmux.h"
#include "hardware/kinetis_sim.h"
#include "hardware/kinetis_qspi.h"

#ifdef CONFIG_KINETIS_QSPI

/****************************************************************************
 * Pre-processor Definitions
 ****************************************************************************/

/* Configuration ************************************************************/

/* The Watermark value for read transfers (in 32 bit words) */

#define KINETIS_QSPI_RX_WATERMARK    4  /* 16 bytes */

/* Clocking *****************************************************************/

/* The QSPI Baud rate clock is generated by dividing the peripheral clock by
 * a value between 1 and 255
 */

#define KINETIS_QSPI_CLOCK    BOARD_QSPI_CLOCK_FREQ  /* Frequency of the main clock */

/* DMA timeout.  The value is not critical; we just don't want the system to
 * hang in the event that a DMA does not finish.  This is set to
 */

#define DMA_TIMEOUT_MS    (800)
#define DMA_TIMEOUT_TICKS MSEC2TICK(DMA_TIMEOUT_MS)

/* QSPI memory synchronization */

#define MEMORY_SYNC()     do { ARM_DSB(); ARM_ISB(); } while (0)

/* The KINETIS QSPI driver insists that transfers be performed in multiples
 * of 32-bits.  The alignment requirement only applies to RX DMA data.
 */

#define ALIGN_SHIFT       2
#define ALIGN_MASK        3
#define ALIGN_UP(n)       (((n)+ALIGN_MASK) & ~ALIGN_MASK)
#define IS_ALIGNED(n)     (((uint32_t)(n) & ALIGN_MASK) == 0)

/* QSPI inline macros **************************************************/

/* Wait while interface busy */

#define QSPI_WAIT_BUSY(p) \
  do \
    { \
      uint32_t r = qspi_getreg(p, KINETIS_QSPI_SR_OFFSET); \
      if ((r & QSPI_SR_BUSY) == 0) \
        { \
          break; \
        } \
    } \
  while (1)

/* Wait for TX FIFO not full */

#define QSPI_WAIT_TXFIFO(p) \
  do \
    { \
      uint32_t r = qspi_getreg(p, KINETIS_QSPI_SR_OFFSET); \
      if ((r & QSPI_SR_TXFULL) == 0 || (r & QSPI_SR_BUSY) == 0) \
        { \
          break; \
        } \
    } \
  while (1)

/* Clear TX FIFO */

#define QSPI_CLEAR_TXFIFO(p) \
  do \
    { \
      uint32_t r = qspi_getreg(p, KINETIS_QSPI_MCR_OFFSET); \
      r |= QSPI_MCR_CLR_TXF; \
      qspi_putreg(p, r, KINETIS_QSPI_MCR_OFFSET); \
    } \
  while (0)

/* Wait for RX FIFO not empty */

#define QSPI_WAIT_RXFIFO(p) \
  do \
    { \
      uint32_t r = qspi_getreg(p, KINETIS_QSPI_SR_OFFSET); \
      if ((r & QSPI_SR_RXWE) != 0 || (r & QSPI_SR_BUSY) == 0) \
        { \
          break; \
        } \
    } \
  while (1)

/* Buffer POP of RX FIFO */

#define QSPI_POP_RXFIFO(p) qspi_putreg(p, QSPI_FR_RBDF, KINETIS_QSPI_FR_OFFSET)

/* Clear RX FIFO */

#define QSPI_CLEAR_RXFIFO(p) \
  do \
    { \
      uint32_t r = qspi_getreg(p, KINETIS_QSPI_MCR_OFFSET); \
      r |= QSPI_MCR_CLR_RXF; \
      qspi_putreg(p, r, KINETIS_QSPI_MCR_OFFSET); \
    } \
  while (0)

/* Execute IP command */

#define QSPI_EXECUTE_IPCOMMAND(p,seq,len) \
  do \
    { \
      uint32_t r; \
      qspi_putreg(p, KINETIS_QSPI_SPTRCLR_OFFSET, QSPI_SPTRCLR_IPPTRC); \
      r  = qspi_getreg(p, KINETIS_QSPI_IPCR_OFFSET); \
      r &= ~(QSPI_IPCR_SEQID_MASK | QSPI_IPCR_IDATSZ_MASK); \
      r |= QSPI_IPCR_SEQID(seq) | QSPI_IPCR_IDATSZ(len); \
      qspi_putreg(priv, r, KINETIS_QSPI_IPCR_OFFSET); \
    } \
  while (0)

/* Execute AHB command */

#define QSPI_EXECUTE_AHBCOMMAND(p,seq,len) \
  do \
    { \
      uint32_t r; \
      qspi_putreg(p, KINETIS_QSPI_SPTRCLR_OFFSET, QSPI_SPTRCLR_BFPTRC); \
      r  = qspi_getreg(p, KINETIS_QSPI_BFGENCR_OFFSET); \
      r &= ~(QSPI_BFGENCR_SEQID_MASK); \
      r |= QSPI_BFGENCR_SEQID(seq); \
      qspi_putreg(priv, r, KINETIS_QSPI_BFGENCR_OFFSET); \
    } \
  while (0)


/****************************************************************************
 * Private Types
 ****************************************************************************/

/* The state of the QSPI controller.
 *
 * NOTE: Currently the KINETIS supports only a single QSPI peripheral.  Logic
 * here is designed to support multiple QSPI peripherals.
 */

struct kinetis_qspidev_s
{
  struct kqspi_dev_s qspi;      /* Externally visible part of the QSPI interface */
  uint32_t base;               /* QSPI controller register base address */
  uint32_t frequency;          /* Requested clock frequency */
  uint32_t actual;             /* Actual clock frequency */
  uint8_t intf;                /* QSPI controller number (0) */
  bool initialized;            /* TRUE: Controller has been initialized */
  sem_t exclsem;               /* Assures mutually exclusive access to QSPI */

  /* Debug stuff */

#ifdef CONFIG_KINETIS_QSPI_REGDEBUG
  bool     wrlast;             /* Last was a write */
  uint32_t addresslast;        /* Last address */
  uint32_t valuelast;          /* Last value */
  int      ntimes;             /* Number of times */
#endif
};

/****************************************************************************
 * Private Function Prototypes
 ****************************************************************************/

/* Helpers */

#ifdef CONFIG_KINETIS_QSPI_REGDEBUG
static bool     qspi_checkreg(struct kinetis_qspidev_s *priv, bool wr,
                  uint32_t value, uint32_t address);
#else
# define        qspi_checkreg(priv,wr,value,address) (false)
#endif

static inline uint32_t qspi_getreg(struct kinetis_qspidev_s *priv,
                  unsigned int offset);
static inline void qspi_putreg(struct kinetis_qspidev_s *priv, uint32_t value,
                  unsigned int offset);

#ifdef CONFIG_DEBUG_SPI_INFO
static void     qspi_dumpregs(struct kinetis_qspidev_s *priv, const char *msg);
#else
# define        qspi_dumpregs(priv,msg)
#endif

static void     qspi_memcpy(uint8_t *dest, const uint8_t *src,
                  size_t buflen);

/* QSPI methods */

static int      qspi_lock(FAR struct kqspi_dev_s *dev, bool lock);
static uint32_t qspi_setfrequency(FAR struct kqspi_dev_s *dev,
                                  uint32_t frequency);
static FAR void *qspi_alloc(FAR struct kqspi_dev_s *dev, size_t buflen);
static void     qspi_free(FAR struct kqspi_dev_s *dev, FAR void *buffer);
static int      qspi_command(FAR struct kqspi_dev_s *dev,
                  FAR struct kqspi_cmdinfo_s *cmdinfo);
static void     qspi_setconfig(FAR struct kqspi_dev_s *dev,
                  FAR struct kqspi_config_s *conf);
static void     qspi_setlut(FAR struct kqspi_dev_s *dev, FAR uint32_t *lut);

/* Initialization */

static int      qspi_hw_initialize(struct kinetis_qspidev_s *priv);

/****************************************************************************
 * Private Data
 ****************************************************************************/

#ifdef CONFIG_KINETIS_QSPI
/* QSPI0 driver operations */

static const struct kqspi_ops_s g_qspi0ops =
{
  .lock              = qspi_lock,
  .setfrequency      = qspi_setfrequency,
  .command           = qspi_command,
  .alloc             = qspi_alloc,
  .free              = qspi_free,
  .setconfig         = qspi_setconfig,
  .setlut            = qspi_setlut
};

/* This is the overall state of the QSPI0 controller */

static struct kinetis_qspidev_s g_qspi0dev =
{
  .qspi            =
  {
    .ops             = &g_qspi0ops,
  },
  .base              = KINETIS_QSPI0C_BASE,
  .intf              = 0,
};
#endif /* CONFIG_KINETIS_QSPI */

/****************************************************************************
 * Public Data
 ****************************************************************************/

/****************************************************************************
 * Private Functions
 ****************************************************************************/

/****************************************************************************
 * Name: qspi_checkreg
 *
 * Description:
 *   Check if the current register access is a duplicate of the preceding.
 *
 * Input Parameters:
 *   value   - The value to be written
 *   address - The address of the register to write to
 *
 * Returned Value:
 *   true:  This is the first register access of this type.
 *   flase: This is the same as the preceding register access.
 *
 ****************************************************************************/

#ifdef CONFIG_KINETIS_QSPI_REGDEBUG
static bool qspi_checkreg(struct kinetis_qspidev_s *priv, bool wr,
                          uint32_t value, uint32_t address)
{
  if (wr      == priv->wrlast &&     /* Same kind of access? */
      value   == priv->valuelast &&  /* Same value? */
      address == priv->addresslast)  /* Same address? */
    {
      /* Yes, then just keep a count of the number of times we did this. */

      priv->ntimes++;
      return false;
    }
  else
    {
      /* Did we do the previous operation more than once? */

      if (priv->ntimes > 0)
        {
          /* Yes... show how many times we did it */

          spiinfo("...[Repeats %d times]...\n", priv->ntimes);
        }

      /* Save information about the new access */

      priv->wrlast      = wr;
      priv->valuelast   = value;
      priv->addresslast = address;
      priv->ntimes      = 0;
    }

  /* Return true if this is the first time that we have done this operation */

  return true;
}
#endif

/****************************************************************************
 * Name: qspi_getreg
 *
 * Description:
 *  Read an QSPI register
 *
 ****************************************************************************/

static inline uint32_t qspi_getreg(struct kinetis_qspidev_s *priv,
                                  unsigned int offset)
{
  uint32_t address = priv->base + offset;
  uint32_t value = getreg32(address);

#ifdef CONFIG_KINETIS_QSPI_REGDEBUG
  if (qspi_checkreg(priv, false, value, address))
    {
      spiinfo("%08x->%08x\n", address, value);
    }
#endif

  return value;
}

/****************************************************************************
 * Name: qspi_putreg
 *
 * Description:
 *  Write a value to an QSPI register
 *
 ****************************************************************************/

static inline void qspi_putreg(struct kinetis_qspidev_s *priv, uint32_t value,
                              unsigned int offset)
{
  uint32_t address = priv->base + offset;

#ifdef CONFIG_KINETIS_QSPI_REGDEBUG
  if (qspi_checkreg(priv, true, value, address))
    {
      spiinfo("%08x<-%08x\n", address, value);
    }
#endif

  putreg32(value, address);
}

/****************************************************************************
 * Name: qspi_dumpregs
 *
 * Description:
 *   Dump the contents of all QSPI registers
 *
 * Input Parameters:
 *   priv - The QSPI controller to dump
 *   msg - Message to print before the register data
 *
 * Returned Value:
 *   None
 *
 ****************************************************************************/

#ifdef CONFIG_DEBUG_SPI_INFO
static void qspi_dumpregs(struct kinetis_qspidev_s *priv, const char *msg)
{
  spiinfo("%s:\n", msg);
  spiinfo("    MCR:%08x   IPCR:%08x FLSHCR:%08x  SOCCR:%08x\n",
         getreg32(priv->base + KINETIS_QSPI_MCR_OFFSET),
         getreg32(priv->base + KINETIS_QSPI_IPCR_OFFSET),
         getreg32(priv->base + KINETIS_QSPI_FLSHCR_OFFSET),
         getreg32(priv->base + KINETIS_QSPI_SOCCR_OFFSET));
  spiinfo("     SR:%08x     FR:%08x   RSER:%08x\n",
         getreg32(priv->base + KINETIS_QSPI_SR_OFFSET),
         getreg32(priv->base + KINETIS_QSPI_FR_OFFSET),
         getreg32(priv->base + KINETIS_QSPI_RSER_OFFSET));
}
#endif

/****************************************************************************
 * Name: qspi_memcpy
 *
 * Description:
 *   32-bit version of memcpy.
 *
 * Input Parameters:
 *   dest   - Destination address of the copy
 *   src    - Source address of the copy
 *   buflen - The number of 32-bit words to copy.
 *
 * Returned Value:
 *   None
 *
 ****************************************************************************/

static void qspi_memcpy(uint8_t *dest, const uint8_t *src, size_t buflen)
{
  /* The size of the SPI transfer is equal to the bus access width.
   * 8-bit transfers should result in in 8-bit SPI accesses.
   */

  for (; buflen > 0; buflen--)
    {
      *dest++ = *src++;
    }
}

/****************************************************************************
 * Name: qspi_lock
 *
 * Description:
 *   On QSPI buses where there are multiple devices, it will be necessary to
 *   lock QSPI to have exclusive access to the buses for a sequence of
 *   transfers.  The bus should be locked before the chip is selected. After
 *   locking the QSPI bus, the caller should then also call the setfrequency,
 *   setconfig, and setlut methods to make sure that the QSPI is properly
 *   configured for the device.  If the QSPI bus is being shared, then it
 *   may have been left in an incompatible state.
 *
 * Input Parameters:
 *   dev  - Device-specific state data
 *   lock - true: Lock QSPI bus, false: unlock QSPI bus
 *
 * Returned Value:
 *   None
 *
 ****************************************************************************/

static int qspi_lock(struct kqspi_dev_s *dev, bool lock)
{
  struct kinetis_qspidev_s *priv = (struct kinetis_qspidev_s *)dev;
  int ret;

  spiinfo("lock=%d\n", lock);
  if (lock)
    {
      ret = nxsem_wait_uninterruptible(&priv->exclsem);
    }
  else
    {
      ret = nxsem_post(&priv->exclsem);
    }

  return ret;
}

/****************************************************************************
 * Name: qspi_setfrequency
 *
 * Description:
 *   Set the QSPI frequency.
 *
 * Input Parameters:
 *   dev -       Device-specific state data
 *   frequency - The QSPI frequency requested
 *
 * Returned Value:
 *   Returns the actual frequency selected
 *
 ****************************************************************************/

static uint32_t qspi_setfrequency(struct kqspi_dev_s *dev, uint32_t frequency)
{
  struct kinetis_qspidev_s *priv = (struct kinetis_qspidev_s *)dev;
  uint32_t actual;
  uint32_t sclkcfg;
  uint32_t regval;

  spiinfo("frequency=%d\n", frequency);
  DEBUGASSERT(priv);

  /* Check if the requested frequency is the same as the frequency
   * selection
   */

  if (priv->frequency == frequency)
    {
      /* We are already at this frequency.  Return the actual. */

      return priv->actual;
    }

  /* Configure QSPI to a frequency as close as possible to the requested
   * frequency.
   *
   *   QSCK frequency = QSPI_CLK / SCLKCFG, or SCLKCFG = QSPI_CLK / frequency
   *
   * Where SCLKCFG can have the range 1 to 256 and the MCR register field holds
   * SCLKCFG - 1.  NOTE that a "ceiling" type of calculation is performed.
   * 'frequency' is treated as a not-to-exceed value.
   */

  sclkcfg = (frequency + KINETIS_QSPI_CLOCK - 1) / frequency;

  /* Make sure that the divider is within range */

  if (sclkcfg < 1)
    {
      sclkcfg = 1;
    }
  else if (sclkcfg > 16)
    {
      sclkcfg = 16;
    }

  /* Save the new SCBR value (minus one) */

  regval  = qspi_getreg(priv, KINETIS_QSPI_MCR_OFFSET);
  regval &= ~(QSPI_MCR_SCLKCFG_MASK);
  regval |= (sclkcfg - 1) << QSPI_MCR_SCLKCFG_SHIFT;

  qspi_putreg(priv, regval, KINETIS_QSPI_MCR_OFFSET);

  /* Calculate the new actual frequency */

  actual = KINETIS_QSPI_CLOCK / sclkcfg;
  spiinfo("SCBR=%d actual=%d\n", sclkcfg, actual);

  /* Save the frequency setting */

  priv->frequency = frequency;
  priv->actual    = actual;

  spiinfo("Frequency %d->%d\n", frequency, actual);
  return actual;
}

/****************************************************************************
 * Name: qspi_write_blocking
 *
 * Description:
 *   Write data to TX FIFO (blocking)
 *
 * Input Parameters:
 *   priv    - Device-specific state data
 *   buffer  - Data buffer
 *   buflen  - Length of buffer in bytes
 *
 * Returned Value:
 *   Number of bytes transferred
 *
 ****************************************************************************/

static size_t qspi_write_blocking(struct kinetis_qspidev_s *priv,
                                  uint8_t *buffer, size_t buflen)
{
  size_t bufdone = 0;

  if (IS_ALIGNED(buffer) && IS_ALIGNED(buflen))
    {
      uint32_t *buf32 = (uint32_t *)buffer;
      while (bufdone < buflen)
        {
          QSPI_WAIT_TXFIFO(priv);
          qspi_putreg(priv, *buf32, KINETIS_QSPI_TBDR_OFFSET);
          bufdone += sizeof(uint32_t);
          buf32++;
        }
    }
  else
    {
      while (bufdone < buflen)
        {
          uint32_t temp32 = 0;
          size_t len = buflen - bufdone;

          if (len > sizeof(uint32_t))
            {
              len = sizeof(uint32_t);
            }

          qspi_memcpy((uint8_t *)&temp32, buffer, len);

          QSPI_WAIT_TXFIFO(priv);
          qspi_putreg(priv, temp32, KINETIS_QSPI_TBDR_OFFSET);
          bufdone += len;
          buffer += len;
        }
    }

  return bufdone;
}

/****************************************************************************
 * Name: qspi_read_blocking
 *
 * Description:
 *   Read data from RX FIFO (blocking)
 *
 * Input Parameters:
 *   priv    - Device-specific state data
 *   buffer  - Data buffer
 *   buflen  - Length of buffer in bytes
 *
 * Returned Value:
 *   Number of bytes transferred
 *
 ****************************************************************************/

static size_t qspi_read_blocking(struct kinetis_qspidev_s *priv,
                                 uint8_t *buffer, size_t buflen)
{
  size_t bufdone = 0;
  uint32_t i;

  if (IS_ALIGNED(buffer) && IS_ALIGNED(buflen))
    {
      uint32_t *buf32 = (uint32_t *)buffer;
      while (bufdone < buflen)
        {
          QSPI_WAIT_RXFIFO(priv);
          for (i = 0; i < KINETIS_QSPI_RX_WATERMARK && bufdone < buflen; i++)
            {
              *buf32 = qspi_getreg(priv, KINETIS_QSPI_RBDR_OFFSET + (i << 2));
              bufdone += sizeof(uint32_t);
              buf32++;
            }
          QSPI_POP_RXFIFO(priv);
        }
    }
  else
    {
      while (bufdone < buflen)
        {
          QSPI_WAIT_RXFIFO(priv);
          for (i = 0; i < KINETIS_QSPI_RX_WATERMARK && bufdone < buflen; i++)
            {
              uint32_t temp32;
              size_t len = buflen - bufdone;

              if (len > sizeof(uint32_t))
                {
                  len = sizeof(uint32_t);
                }

              temp32 = qspi_getreg(priv, KINETIS_QSPI_RBDR_OFFSET + (i << 2));
              qspi_memcpy(buffer, (uint8_t *)&temp32, len);
              bufdone += len;
              buffer += len;
            }
          QSPI_POP_RXFIFO(priv);
        }
    }

  return bufdone;
}

/****************************************************************************
 * Name: qspi_command
 *
 * Description:
 *   Perform one QSPI data transfer
 *
 * Input Parameters:
 *   dev     - Device-specific state data
 *   cmdinfo - Describes the command transfer to be performed.
 *
 * Returned Value:
 *   Zero (OK) on SUCCESS, a negated errno on value of failure
 *
 ****************************************************************************/

static int qspi_command(struct kqspi_dev_s *dev,
                        struct kqspi_cmdinfo_s *cmdinfo)
{
  struct kinetis_qspidev_s *priv = (struct kinetis_qspidev_s *)dev;

  DEBUGASSERT(priv != NULL && cmdinfo != NULL);

#ifdef CONFIG_DEBUG_SPI_INFO
  spiinfo("Transfer:\n");
  spiinfo("  flags: %02x\n", cmdinfo->flags);
  spiinfo("  lut: %04x\n", cmdinfo->cmdindex);

  if (QSPICMD_ISADDRESS(cmdinfo->flags))
    {
      spiinfo("  address: %08lx\n",
              (unsigned long)cmdinfo->addr);
    }

  if (QSPICMD_ISDATA(cmdinfo->flags))
    {
      spiinfo("  %s Data:\n",
              QSPICMD_ISWRITE(cmdinfo->flags) ? "Write" : "Read");
      spiinfo("    buffer/length: %p/%d\n",
              cmdinfo->buffer, cmdinfo->buflen);
    }
#endif

  DEBUGASSERT(cmdinfo->cmdindex < 16);

  QSPI_WAIT_BUSY(priv);

  /* Write the instruction address register */

  if (QSPICMD_ISADDRESS(cmdinfo->flags))
    {

      /* Set the address in the SFAR. */

      qspi_putreg(priv, cmdinfo->addr, KINETIS_QSPI_SFAR_OFFSET);

    }

  /* Does the command include data? */

  if (QSPICMD_ISDATA(cmdinfo->flags))
    {
      FAR uint8_t *buffer = (FAR uint8_t *)cmdinfo->buffer;

      DEBUGASSERT(buffer != NULL && cmdinfo->buflen > 0);

      if (QSPICMD_ISWRITE(cmdinfo->flags))
        {
          size_t bufdone;

          /* Clear the TX FIFO. */

          QSPI_CLEAR_TXFIFO(priv);

          /* Execute Write Enable command if configured. */

          if (cmdinfo->wrenindex != QSPICMD_INVALID_WREN)
            {
              DEBUGASSERT(cmdinfo->wrenindex < 16);

              QSPI_EXECUTE_IPCOMMAND(priv, cmdinfo->wrenindex, 0);
            }

          /* Fill the Fifo to prevent underrun before exec. the command. */

          bufdone = qspi_write_blocking(priv, buffer,
              cmdinfo->buflen > KINETIS_QSPI_TXFIFO_SIZE ?
                  KINETIS_QSPI_TXFIFO_SIZE : cmdinfo->buflen);

          /* Execute. the command. */

          QSPI_EXECUTE_IPCOMMAND(priv, cmdinfo->cmdindex,
                                 cmdinfo->buflen);

          /* Write the remaining data if present. */

          if (cmdinfo->buflen - bufdone > 0)
            {
              qspi_write_blocking(priv, &buffer[bufdone],
                                  cmdinfo->buflen - bufdone);
            }
        }
      else
        {
          /* Clear the RX FIFO. */

          QSPI_CLEAR_RXFIFO(priv);

          /* Execute the command. */

          QSPI_EXECUTE_IPCOMMAND(priv, cmdinfo->cmdindex,
                                 cmdinfo->buflen);

          /* Read the data. */

          qspi_read_blocking(priv, buffer, cmdinfo->buflen);
        }
    }
  else
    {
      QSPI_EXECUTE_IPCOMMAND(priv, cmdinfo->cmdindex, cmdinfo->buflen);
    }
  return OK;
}

/****************************************************************************
 * Name: qspi_alloc
 *
 * Description:
 *   Allocate a buffer suitable for DMA data transfer
 *
 * Input Parameters:
 *   dev    - Device-specific state data
 *   buflen - Buffer length to allocate in bytes
 *
 * Returned Value:
 *   Address of the allocated memory on success; NULL is returned on any
 *   failure.
 *
 ****************************************************************************/

static FAR void *qspi_alloc(FAR struct kqspi_dev_s *dev, size_t buflen)
{
  /* Here we exploit the internal knowledge the kmm_malloc() will return
   * memory aligned to 64-bit addresses.  The buffer length must be large
   * enough to hold the rested buflen in units a 32-bits.
   */

  return kmm_malloc(ALIGN_UP(buflen));
}

/****************************************************************************
 * Name: QSPI_FREE
 *
 * Description:
 *   Free memory returned by QSPI_ALLOC
 *
 * Input Parameters:
 *   dev    - Device-specific state data
 *   buffer - Buffer previously allocated via QSPI_ALLOC
 *
 * Returned Value:
 *   None.
 *
 ****************************************************************************/

static void qspi_free(FAR struct kqspi_dev_s *dev, FAR void *buffer)
{
  if (buffer)
    {
      kmm_free(buffer);
    }
}

/****************************************************************************
 * Name: qspi_hw_initialize
 *
 * Description:
 *   Initialize the QSPI peripheral from hardware reset.
 *
 * Input Parameters:
 *   priv - Device state structure.
 *
 * Returned Value:
 *   Zero (OK) on SUCCESS, a negated errno on value of failure
 *
 ****************************************************************************/

static int qspi_hw_initialize(struct kinetis_qspidev_s *priv)
{
  uint32_t regval;

  /* Disable the QSPI */

  qspi_putreg(priv, QSPI_CR_QSPIDIS, SAM_QSPI_CR_OFFSET);
  while ((qspi_getreg(priv, SAM_QSPI_SR_OFFSET) & QSPI_SR_QSPIENS) != 0);

  /* Reset the QSPI (twice) */

  qspi_putreg(priv, QSPI_CR_SWRST, SAM_QSPI_CR_OFFSET);
  qspi_putreg(priv, QSPI_CR_SWRST, SAM_QSPI_CR_OFFSET);

  /* Configure the QSPI
   *
   *   QSPI_MR_SMM             - Serial Memory Mode
   *   QSPI_MR_CSMODE_LASTXFER - CS de-asserted when LASTXFER transferred
   */

  regval = QSPI_MR_SMM;
  qspi_putreg(priv, regval, SAM_QSPI_MR_OFFSET);

  regval |= QSPI_MR_CSMODE_LASTXFER;
  qspi_putreg(priv, regval, SAM_QSPI_MR_OFFSET);

  /* Set up the initial QSPI clock mode:
   *
   * Mode 0:  CPOL=0; CPHA=0
   */

  regval  = qspi_getreg(priv, SAM_QSPI_SCR_OFFSET);
  regval &= ~(QSPI_SCR_CPOL | QSPI_SCR_CPHA);
  qspi_putreg(priv, regval, SAM_QSPI_SCR_OFFSET);

  regval |= QSPI_SCR_SCBR(1);
  qspi_putreg(priv, regval, SAM_QSPI_SCR_OFFSET);

  /* 8-bit mode */

  regval  = qspi_getreg(priv, SAM_QSPI_MR_OFFSET);
  regval &= ~QSPI_MR_NBBITS_MASK;
  regval |= QSPI_MR_NBBITS_8BIT;
  qspi_putreg(priv, regval, SAM_QSPI_MR_OFFSET);

  priv->nbits = 8;

  /* Enable QSPI */

  qspi_putreg(priv, QSPI_CR_QSPIEN, SAM_QSPI_CR_OFFSET);
  while ((qspi_getreg(priv, SAM_QSPI_SR_OFFSET) & QSPI_SR_QSPIENS) == 0);

  /* Flush any pending transfers */

  qspi_getreg(priv, SAM_QSPI_SR_OFFSET);
  qspi_getreg(priv, SAM_QSPI_RDR_OFFSET);

  qspi_dumpregs(priv, "After initialization");
  return OK;
}

/****************************************************************************
 * Public Functions
 ****************************************************************************/

/****************************************************************************
 * Name: kinetis_qspi_initialize
 *
 * Description:
 *   Initialize the selected QSPI port in master mode
 *
 * Input Parameters:
 *   intf - Interface number(must be zero)
 *
 * Returned Value:
 *   Valid QSPI device structure reference on success; a NULL on failure
 *
 ****************************************************************************/

struct kqspi_dev_s *kinetis_qspi_initialize(int intf)
{
  struct kinetis_qspidev_s *priv;
  int ret;

  /* The supported Kinetis parts have only a single QSPI port */

  spiinfo("intf: %d\n", intf);
  DEBUGASSERT(intf >= 0 && intf < KINETIS_NQSPI);

  /* Select the QSPI interface */

#ifdef CONFIG_KINETIS_QSPI
  if (intf == 0)
    {
      /* If this function is called multiple times, the following operations
       * will be performed multiple times.
       */

      uint32_t regval;

      /* Select QSPI0 */

      priv = &g_qspi0dev;

      /* Enable clocking to the QSPI peripheral */

#ifdef KINETIS_SIM_HAS_SCGC2_QSPI
      regval  = getreg32(KINETIS_SIM_SCGC2);
      regval |= (SIM_SCGC2_QSPI);
      putreg32(regval, KINETIS_SIM_SCGC2);
#endif

      /* Select clock source for the QSPI peripheral */

      regval  = qspi_getreg(priv, KINETIS_QSPI_SOCCR_OFFSET);
      regval &= ~(QSPI_SOCCR_QSPISRC_MASK);
      regval |= QSPI_SOCCR_QSPISRC(BOARD_QSPI_CLOCK_SOCCR);
      qspi_putreg(priv, regval, KINETIS_QSPI_SOCCR_OFFSET);;

      /* Configure multiplexed pins as connected on the board. */

      kinetis_pinconfig(PIN_QSPI0A_SS0_B);
      kinetis_pinconfig(PIN_QSPI0A_DATA0);
      kinetis_pinconfig(PIN_QSPI0A_DATA1);
      kinetis_pinconfig(PIN_QSPI0A_DATA2);
      kinetis_pinconfig(PIN_QSPI0A_DATA3);
      kinetis_pinconfig(PIN_QSPI0A_SCLK);
    }
  else
#endif
    {
      spierr("ERROR: QSPI%d not supported\n", intf);
      return NULL;
    }

  /* Has the QSPI hardware been initialized? */

  if (!priv->initialized)
    {
      /* No perform one time initialization */

      /* Initialize the QSPI semaphore that enforces mutually exclusive
       * access to the QSPI registers.
       */

      nxsem_init(&priv->exclsem, 0, 1);

      /* Perform hardware initialization.  Puts the QSPI into an active
       * state.
       */

      ret = qspi_hw_initialize(priv);
      if (ret < 0)
        {
          spierr("ERROR: Failed to initialize QSPI hardware\n");
          goto errout;
        }

      priv->initialized = true;
    }

  return &priv->qspi;

errout:
  nxsem_destroy(&priv->exclsem);
  return NULL;
}
#endif /* CONFIG_KINETIS_QSPI */
